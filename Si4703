# -------------------------------------------------------------
#   CÓDIGO 1: PRUEBA BÁSICA SI4703 (SIN PANTALLA NI BOTONES)
#   Objetivo: Verificar que la radio sintoniza y se escucha.
# -------------------------------------------------------------

from machine import Pin, I2C
import time

# --- CLASE DEL DRIVER SI4703 (Motor de la radio) ---
class SI4703_Simple:
    I2C_ADDR = 0x10
    
    def __init__(self, i2c, pin_reset, pin_sdio):
        self.i2c = i2c
        self.rst = Pin(pin_reset, Pin.OUT)
        self.sdio = Pin(pin_sdio, Pin.OUT)
        self.shadow = [0] * 16 # Memoria de registros

    def start(self):
        print("Iniciando radio...")
        # 1. Reset Físico (Secuencia especial para modo I2C)
        self.sdio.value(0)
        time.sleep_ms(10)
        self.rst.value(0)
        time.sleep_ms(10)
        self.rst.value(1)
        time.sleep_ms(10)
        
        # 2. Encender Oscilador
        self._read()
        self.shadow[0x07] = 0x8100 # Test1 Register -> Enable XOSC
        self._write()
        time.sleep_ms(500) # ESPERA IMPORTANTE (Cargar el cristal)
        
        # 3. Encender Sonido
        self._read()
        self.shadow[0x02] = 0x4001 # PowerConfig -> Enable + DMute
        self.shadow[0x05] |= 0x0001 # SysConfig2 -> Espaciado europeo
        self._write()
        time.sleep_ms(110)
        print("¡Radio encendida!")

    def tune(self, freq):
        # Sintonizar una frecuencia (ej. 101.5)
        channel = int((freq - 87.5) / 0.1)
        self._read()
        self.shadow[0x03] &= 0xFE00 
        self.shadow[0x03] |= channel
        self.shadow[0x03] |= (1 << 15) # Bit TUNE
        self._write()
        
        # Esperar a que termine
        while True:
            self._read()
            if self.shadow[0x0A] & (1 << 14): break # Bit STC
            time.sleep_ms(20)
            
        self.shadow[0x03] &= ~(1 << 15) # Apagar bit TUNE
        self._write()
        print(f"Sintonizado en: {freq} MHz")

    def set_volume(self, vol):
        # Volumen del 0 al 15
        self._read()
        self.shadow[0x05] = (self.shadow[0x05] & 0xFFF0) | vol
        self._write()
        print(f"Volumen puesto a: {vol}")

    # Funciones internas I2C
    def _read(self):
        try:
            d = self.i2c.readfrom(self.I2C_ADDR, 32)
            idx = 0x0A
            for i in range(0, 32, 2):
                self.shadow[idx] = (d[i] << 8) | d[i+1]
                idx = (idx + 1) if idx < 0x0F else 0
        except: print("Error de conexión I2C")

    def _write(self):
        buf = bytearray(12)
        idx = 0
        for r in range(0x02, 0x08):
            buf[idx] = (self.shadow[r] >> 8) & 0xFF
            buf[idx+1] = self.shadow[r] & 0xFF
            idx += 2
        self.i2c.writeto(self.I2C_ADDR, buf)

# --- ZONA DE CONFIGURACIÓN ---
if __name__ == "__main__":
    # Pines
    PIN_SDA = 21
    PIN_SCL = 22
    PIN_RST = 4
    
    # 1. Configurar conexión
    i2c = I2C(0, scl=Pin(PIN_SCL), sda=Pin(PIN_SDA), freq=100000)
    radio = SI4703_Simple(i2c, PIN_RST, PIN_SDA)
    
    # 2. Encender
    radio.start()
    
    # 3. Pruebas fijas (CAMBIA ESTOS VALORES A TU GUSTO)
    radio.set_volume(8)      # Pone volumen 8
    radio.tune(98.5)         # Sintoniza 98.5 MHz
    
    print("Si escuchas ruido o música, todo está bien.")
