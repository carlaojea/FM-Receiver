# -------------------------------------------------------------
#   RADIO FM SI4703 - VERSIÓN FINAL
#   Hardware: ESP32 + OLED 1.3" (SH1106) + 5 Botones
# -------------------------------------------------------------

from machine import Pin, I2C
import time
import sh1106  # <--- IMPORTANTE: Usamos el driver SH1106

# =============================================================
#  1. DRIVER PARA RADIO SI4703 (Capa de Hardware)
# =============================================================
class SI4703_Driver:
    I2C_ADDR = 0x10
    
    def __init__(self, i2c, pin_rst, pin_sdio):
        self.i2c = i2c
        self.rst = Pin(pin_rst, Pin.OUT)
        self.sdio = Pin(pin_sdio, Pin.OUT)
        self.shadow = [0] * 16 # Copia local de registros

    def init(self):
        # Secuencia de Reset para modo I2C
        self.sdio.value(0)
        time.sleep_ms(10)
        self.rst.value(0)
        time.sleep_ms(10)
        self.rst.value(1)
        time.sleep_ms(10)
        
        # 1. Encender Oscilador
        self._read()
        self.shadow[0x07] = 0x8100 # Registro Test1
        self._write()
        time.sleep_ms(500) # ESPERA CRÍTICA
        
        # 2. Encender Audio (PowerUp + Desactivar Mute)
        self._read()
        self.shadow[0x02] = 0x4001 
        self.shadow[0x05] |= 0x0001 # Espaciado europeo
        self._write()
        time.sleep_ms(110)

    def set_vol(self, v):
        # Limitar entre 0 y 15
        v = max(0, min(15, v))
        self._read()
        # Borrar bits viejos y poner los nuevos
        self.shadow[0x05] = (self.shadow[0x05] & 0xFFF0) | v
        self._write()

    def tune_step(self, up=True):
        # Sintonizar 0.1 MHz arriba o abajo
        self._read()
        chan = self.shadow[0x03] & 0x03FF
        if up: chan += 1
        else: chan -= 1
        
        # Activar bit TUNE (bit 15)
        self.shadow[0x03] = (self.shadow[0x03] & 0xFE00) | chan | (1 << 15)
        self._write()
        
        self._wait_stc() # Esperar a que termine
        
        # Apagar bit TUNE
        self.shadow[0x03] &= ~(1 << 15)
        self._write()

    def seek(self, up=True):
        # Búsqueda automática
        self._read()
        # Configurar dirección (bit 9)
        if up: self.shadow[0x02] |= (1 << 9)
        else: self.shadow[0x02] &= ~(1 << 9)
        
        # Activar bit SEEK (bit 8)
        self.shadow[0x02] |= (1 << 8)
        self._write()
        
        self._wait_stc() # Esperar a que termine
        
        # Apagar bit SEEK
        self.shadow[0x02] &= ~(1 << 8)
        self._write()

    def get_info(self):
        # Devolver: (Frecuencia, Volumen, Señal)
        self._read()
        chan = self.shadow[0x0B] & 0x03FF
        freq = 87.5 + (chan * 0.1)
        vol = self.shadow[0x05] & 0x0F
        rssi = self.shadow[0x0A] & 0xFF
        return freq, vol, rssi

    # --- Funciones internas ---
    def _wait_stc(self):
        while True:
            self._read()
            # Verificar bit STC (Seek/Tune Complete) en registro 0x0A
            if self.shadow[0x0A] & (1 << 14): break
            time.sleep_ms(20)

    def _read(self):
        try:
            d = self.i2c.readfrom(self.I2C_ADDR, 32)
            idx = 0x0A
            for i in range(0, 32, 2):
                self.shadow[idx] = (d[i] << 8) | d[i+1]
                idx += 1
                if idx > 0x0F: idx = 0x00
        except OSError:
            pass # Ignorar errores puntuales de I2C

    def _write(self):
        buf = bytearray(12)
        idx = 0
        for r in range(0x02, 0x08):
            buf[idx] = (self.shadow[r] >> 8) & 0xFF
            buf[idx+1] = self.shadow[r] & 0xFF
            idx += 2
        self.i2c.writeto(self.I2C_ADDR, buf)

# =============================================================
#  2. SISTEMA DE MENÚ (Capa de Lógica/Pantalla)
# =============================================================
class MenuSystem:
    def __init__(self, radio, display, pins):
        self.radio = radio
        self.oled = display
        
        # Configurar botones con PULL_UP (Se activan con GND/0)
        self.btn_up     = Pin(pins[0], Pin.IN, Pin.PULL_UP)
        self.btn_down   = Pin(pins[1], Pin.IN, Pin.PULL_UP)
        self.btn_left   = Pin(pins[2], Pin.IN, Pin.PULL_UP)
        self.btn_right  = Pin(pins[3], Pin.IN, Pin.PULL_UP)
        self.btn_center = Pin(pins[4], Pin.IN, Pin.PULL_UP)
        
        self.cursor = 0 # 0 = Frecuencia, 1 = Volumen
        self.update_ui()

    def check_buttons(self):
        act = False
        
        # --- NAVEGACIÓN (Arriba/Abajo) ---
        if self.btn_up.value() == 0:
            self.cursor = 0
            act = True
            time.sleep(0.2) # Anti-rebote
        elif self.btn_down.value() == 0:
            self.cursor = 1
            act = True
            time.sleep(0.2)

        # --- ACCIÓN (Izq/Der/Centro) ---
        if self.cursor == 0: # ESTAMOS EN FRECUENCIA
            if self.btn_left.value() == 0:
                self.radio.tune_step(up=False)
                act = True
            elif self.btn_right.value() == 0:
                self.radio.tune_step(up=True)
                act = True
            elif self.btn_center.value() == 0:
                self.oled.fill(0)
                self.oled.text("Buscando...", 25, 30)
                self.oled.show()
                self.radio.seek(up=True)
                act = True

        elif self.cursor == 1: # ESTAMOS EN VOLUMEN
            current_vol = self.radio.get_info()[1]
            if self.btn_left.value() == 0:
                self.radio.set_vol(current_vol - 1)
                act = True
                time.sleep(0.1) # Pausa corta para volumen fluido
            elif self.btn_right.value() == 0:
                self.radio.set_vol(current_vol + 1)
                act = True
                time.sleep(0.1)
            elif self.btn_center.value() == 0:
                self.radio.set_vol(0) # Mute rápido
                act = True
                time.sleep(0.3)
        
        if act:
            self.update_ui()

    def update_ui(self):
        freq, vol, rssi = self.radio.get_info()
        
        self.oled.fill(0)
        # Título
        self.oled.text("RADIO FM", 35, 0)
        self.oled.hline(0, 10, 128, 1)
        
        # Cursor >
        y_pos = 20 if self.cursor == 0 else 40
        self.oled.text(">", 5, y_pos)
        
        # Datos
        self.oled.text(f"Freq: {freq:.1f}", 20, 20)
        self.oled.text(f"Vol : {vol}", 20, 40)
        
        # Dibujar barra de señal (RSSI)
        width_rssi = int((rssi / 100) * 30)
        self.oled.rect(90, 20, 32, 8, 1)
        self.oled.fill_rect(91, 21, width_rssi, 6, 1)
        
        # Dibujar barra de volumen
        width_vol = int((vol / 15) * 30)
        self.oled.rect(90, 40, 32, 8, 1)
        self.oled.fill_rect(91, 41, width_vol, 6, 1)
        
        # Ayuda inferior
        self.oled.hline(0, 52, 128, 1)
        if self.cursor == 0:
            self.oled.text("[Tune] [Seek]", 10, 55)
        else:
            self.oled.text("[-Vol+] [Mute]", 10, 55)
            
        self.oled.show()

# =============================================================
#  3. BLOQUE PRINCIPAL (Setup)
# =============================================================
if __name__ == "__main__":
    # PINES I2C (Radio y OLED comparten pines)
    PIN_SDA = 21
    PIN_SCL = 22
    PIN_RST_RADIO = 4
    
    # PINES BOTONES [Arriba, Abajo, Izq, Der, Centro]
    PINS_BOTONES = [13, 12, 14, 27, 26]

    # Iniciar I2C
    i2c = I2C(0, scl=Pin(PIN_SCL), sda=Pin(PIN_SDA), freq=100000)

    # Iniciar Pantalla (SH1106)
    try:
        print("Iniciando pantalla...")
        oled = sh1106.SH1106_I2C(128, 64, i2c)
        oled.fill(0)
        oled.text("Iniciando...", 20, 30)
        oled.show()
    except Exception as e:
        print(f"Error Pantalla: {e}")
        print("¿Has subido el archivo sh1106.py?")

    # Iniciar Radio
    print("Iniciando Radio...")
    radio = SI4703_Driver(i2c, PIN_RST_RADIO, PIN_SDA)
    radio.init()
    radio.set_vol(5) # Volumen inicial
    
    # Iniciar Sistema
    menu = MenuSystem(radio, oled, PINS_BOTONES)
    
    print("Sistema listo.")
    
    # Bucle infinito
    while True:
        menu.check_buttons()
        time.sleep(0.05) # Pequeña pausa para descansar CPU
