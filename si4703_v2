
from machine import Pin, I2C
import time
import sh1106 


#  1. DRIVER RADIO SI4703 

class SI4703_Driver:
    I2C_ADDR = 0x10
    
    def __init__(self, i2c, pin_rst, pin_sdio):
        self.i2c = i2c
        self.rst = Pin(pin_rst, Pin.OUT)
        self.sdio = Pin(pin_sdio, Pin.OUT)
        self.shadow = [0] * 16 

    def init(self):
        # Reset 
        self.sdio.value(0); time.sleep_ms(10)
        self.rst.value(0); time.sleep_ms(10)
        self.rst.value(1); time.sleep_ms(10)
        
        # turn on Oscillator
        self._read(); self.shadow[0x07] = 0x8100; self._write()
        time.sleep_ms(500) 
        
        # turn on Audio
        self._read(); self.shadow[0x02] = 0x4001; self.shadow[0x05] |= 1; self._write()
        time.sleep_ms(110)

    def set_vol(self, v):
        v = max(0, min(15, v))
        self._read(); self.shadow[0x05] = (self.shadow[0x05] & 0xFFF0) | v
        self._write()

    def tune(self, freq):
        # EXACT FREQUENCY 
        channel = int((freq - 87.5) / 0.1)
        self._read()
        self.shadow[0x03] = (self.shadow[0x03] & 0xFE00) | channel | (1 << 15)
        self._write(); self._wait_stc()
        self.shadow[0x03] &= ~(1 << 15); self._write()

    def tune_step(self, up=True):
        self._read()
        chan = self.shadow[0x03] & 0x03FF
        chan = (chan + 1) if up else (chan - 1)
        self.shadow[0x03] = (self.shadow[0x03] & 0xFE00) | chan | (1 << 15)
        self._write(); self._wait_stc()
        self.shadow[0x03] &= ~(1 << 15); self._write()

    def seek(self, up=True):
        self._read()
        if up: self.shadow[0x02] |= (1 << 9)
        else: self.shadow[0x02] &= ~(1 << 9)
        self.shadow[0x02] |= (1 << 8); self._write(); self._wait_stc()
        self.shadow[0x02] &= ~(1 << 8); self._write()

    def get_info(self):
        self._read()
        chan = self.shadow[0x0B] & 0x03FF
        return 87.5 + (chan * 0.1), self.shadow[0x05] & 0x0F, self.shadow[0x0A] & 0xFF

    def _wait_stc(self):
        while True:
            self._read()
            if self.shadow[0x0A] & (1 << 14): break
            time.sleep_ms(20)

    def _read(self):
        try:
            d = self.i2c.readfrom(self.I2C_ADDR, 32)
            idx = 0x0A
            for i in range(0, 32, 2):
                self.shadow[idx] = (d[i] << 8) | d[i+1]
                idx = (idx + 1) if idx < 0x0F else 0
        except: pass 

    def _write(self):
        b=bytearray(12); x=0
        for r in range(0x02, 0x08):
            b[x]=(self.shadow[r]>>8)&0xFF; b[x+1]=self.shadow[r]&0xFF; x+=2
        self.i2c.writeto(self.I2C_ADDR, b)


#  2. GRAPHIC INTERFACE
# =============================================================
def actualizar_pantalla(oled, freq, vol, rssi, mensaje_estado=""):
    oled.fill(0)
    
    
    oled.text("RADIO FM", 35, 0)
    oled.hline(0, 10, 128, 1)

    if mensaje_estado != "":
        # Si estamos buscando, mostrar mensaje
        oled.text(mensaje_estado, 20, 30)
    else:
        # HIGH FREQUENCY
        oled.text("FREQ:", 0, 20)
        oled.text(f"{freq:.1f} MHz", 45, 20)

        # Volume
        oled.text("VOL :", 0, 40)
        oled.text(f"{vol}", 45, 40)
        
        # VISUAL VOLUME 
        oled.rect(65, 40, 60, 8, 1)
        ancho = int((vol/15) * 58)
        oled.fill_rect(67, 42, ancho, 4, 1)

        # SIGNAL (RSSI)
        oled.text(f"Sig:{rssi}", 80, 55)

    oled.show()


#  3. MAIN
if __name__ == "__main__":
    # PINS
    PIN_SDA = 21; PIN_SCL = 22; PIN_RST = 4
    PINS_BOTONES = [13, 12, 14, 27, 26]
       
    # Buttons (PULL_UP: Pulsado es 0)
    btn_vol_up    = Pin(13, Pin.IN, Pin.PULL_UP)
    btn_vol_down  = Pin(12, Pin.IN, Pin.PULL_UP)
    btn_freq_up   = Pin(27, Pin.IN, Pin.PULL_UP) # Looking for the next 
    btn_freq_down = Pin(14, Pin.IN, Pin.PULL_UP) # Looking for the previous


    # 1. INICIALIZE I2C 
    print("Starting I2C...")
    i2c = I2C(1, scl=Pin(PIN_SCL), sda=Pin(PIN_SDA), freq=100000)

    # 2. INICIALIZE SCREEN
    try:
        print("Iniciando Pantalla SH1106...")
        oled = sh1106.SH1106_I2C(128, 64, i2c)
        oled.fill(0)
        oled.text("INICIATING...", 20, 30)
        oled.show()
    except Exception as e:
        print("\n!!! ERROR PANTALLA !!!")
        print(f"Detalle: {e}")
        raise SystemExit

    # 3. START RADIO
    print("INICIATING Radio...")
    radio = SI4703_Driver(i2c, PIN_RST, PIN_SDA)
    radio.init()
    
    # INICIAL CONFIGURATION
    vol_actual = 15
    radio.set_vol(vol_actual)
    radio.tune(103.9) 
    

    # 4. INFINITE LOOP
    while True:
        accion = False
        estado = ""
        
        # --- VOLUME ---
        if btn_vol_up.value() == 0:
            if vol_actual < 15:
                vol_actual += 1
                radio.set_vol(vol_actual)
                accion = True
                time.sleep(0.15) # Anti-rebote

        elif btn_vol_down.value() == 0:
            if vol_actual > 0:
                vol_actual -= 1
                radio.set_vol(vol_actual)
                accion = True
                time.sleep(0.15)

        # --- FREQUENCY SEEKING ---
        elif btn_freq_up.value() == 0:
            if oled: actualizar_pantalla(oled, 0, 0, 0, "LOOKING >>")
            radio.seek(True) # Buscar Arriba
            accion = True
            time.sleep(0.3) 

        elif btn_freq_down.value() == 0:
            if oled: actualizar_pantalla(oled, 0, 0, 0, "<< LOOKING")
            radio.seek(False) # Buscar Abajo
            accion = True
            time.sleep(0.3)

        # REFRESH THE SCREEN
        if accion or True: 
            f, v, r = radio.get_info()
            vol_actual = v # Sincronizar
            if oled: actualizar_pantalla(oled, f, v, r)
        
        time.sleep(0.1)


